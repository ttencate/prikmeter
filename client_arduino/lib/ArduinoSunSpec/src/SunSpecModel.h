#pragma once

#include <cmath>
#include <cstdint>

static inline constexpr float uint32_to_float(uint32_t i) {
  static_assert(sizeof(float) == sizeof(uint32_t));
  union U {
    uint32_t i;
    float f;
  };
  U u{ .i = i };
  return u.f;
}

static inline constexpr double uint64_to_double(uint64_t i) {
  static_assert(sizeof(double) == sizeof(uint64_t));
  union U {
    uint64_t i;
    double d;
  };
  U u{ .i = i };
  return u.d;
}

// TODO make this not be in a header, or templatized or something
namespace NotImplemented {
  const int16_t INT16 = 0x8000;
  const int32_t INT32 = 0x80000000;
  const int64_t INT64 = 0x8000000000000000;
  const uint16_t RAW16 = 0xffff; // Missing from the spec.
  const uint16_t UINT16 = 0xffff;
  const uint32_t UINT32 = 0xffffffff;
  const uint64_t UINT64 = 0xffffffffffffffff;
  const uint16_t ACC16 = 0x0000;
  const uint32_t ACC32 = 0x00000000;
  const uint64_t ACC64 = 0x0000000000000000;
  const uint16_t BITFIELD16 = 0xffff;
  const uint32_t BITFIELD32 = 0xffffffff;
  const uint64_t BITFIELD64 = 0xffffffffffffffff; // Missing from the spec.
  const uint16_t ENUM16 = 0xffff;
  const uint32_t ENUM32 = 0xffffffff;
  const float FLOAT32 = uint32_to_float(0x7fc00000);
  const double FLOAT64 = uint64_to_double(0x7ff8000000000000);
  const int16_t SUNSSF = 0x8000;
  const uint32_t IPADDR = 0x00000000;
  // const uint128_t IPV6ADDR = 0x00000000000000000000000000000000;
  const uint64_t EUI48 = 0x0000000000000000; // Missing from the spec.
}

/**
 * A "lazy" parser of a SunSpec model. It contains an array of register values
 * and parses fields from it on request.
 *
 * Autogenerated classes derive from this and add getter functions for each
 * point (field).
 *
 * Note that write access is not currently supported.
 */
template<uint16_t ID, uint16_t LENGTH>
class SunSpecModel {
  public:
    static constexpr uint16_t id() {
      return ID;
    }

    SunSpecModel() {
    }

    ~SunSpecModel() {
      deleteBuffer();
    }

  protected:

    int16_t parse_int16(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return NotImplemented::INT16;
      }
      return static_cast<int16_t>(read_uint16(offset));
    }

    int32_t parse_int32(uint16_t offset) const {
      if (!canRead(offset, 2)) {
        return static_cast<int32_t>(0x80000000);
      }
      return static_cast<int32_t>(read_uint32(offset));
    }

    int64_t parse_int64(uint16_t offset) const {
      if (!canRead(offset, 4)) {
        return static_cast<int64_t>(0x8000000000000000);
      }
      return static_cast<int64_t>(read_uint64(offset));
    }

    uint16_t parse_raw16(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0xffff; // The spec is not clear about this.
      }
      return read_uint16(offset);
    }

    uint16_t parse_uint16(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0xffff;
      }
      return read_uint16(offset);
    }

    uint32_t parse_uint32(uint16_t offset) const {
      if (!canRead(offset, 2)) {
        return 0xffffffff;
      }
      return read_uint32(offset);
    }

    uint64_t parse_uint64(uint16_t offset) const {
      if (!canRead(offset, 4)) {
        return 0xffffffffffffffff;
      }
      return read_uint64(offset);
    }

    uint16_t parse_acc16(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0x0000;
      }
      return read_uint16(offset);
    }

    uint32_t parse_acc32(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0x00000000;
      }
      return read_uint32(offset);
    }

    uint64_t parse_acc64(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0x0000000000000000;
      }
      return read_uint64(offset);
    }

    uint16_t parse_bitfield16(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0xffff;
      }
      return read_uint16(offset);
    }

    uint32_t parse_bitfield32(uint16_t offset) const {
      if (!canRead(offset, 2)) {
        return 0xffffffff;
      }
      return read_uint32(offset);
    }

    uint64_t parse_bitfield64(uint16_t offset) const {
      if (!canRead(offset, 4)) {
        return 0xffffffffffffffff;
      }
      return read_uint64(offset);
    }

    // TODO generate symbolic constants for enum values

    uint16_t parse_enum16(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0xffff;
      }
      return read_uint16(offset);
    }

    uint32_t parse_enum32(uint16_t offset) const {
      if (!canRead(offset, 2)) {
        return 0xffffffff;
      }
      return read_uint32(offset);
    }

    float parse_float32(uint16_t offset) const {
      if (!canRead(offset, 2)) {
        return uint32_to_float(0x7fc00000);
      }
      return uint32_to_float(read_uint32(offset));
    }

    double parse_float64(uint16_t offset) const {
      if (!canRead(offset, 4)) {
        return uint64_to_double(0x7ff8000000000000);
      }
      return uint64_to_double(read_uint64(offset));
    }

    String parse_string(uint16 offset, uint16 length) const {
      String result;
      if (!canRead(offset, length)) {
        return result;
      }
      result.reserve(length);
      uint16 const *const end = buffer_ + offset + length;
      for (uint16 const *curr = buffer_ + offset; curr < end; curr++) {
        uint8 c = (*curr) >> 8;
        if (!c) {
          break;
        }
        result += static_cast<char>(c);
        c = (*curr) & 0xff;
        if (!c) {
          break;
        }
        result += static_cast<char>(c);
      }
      return result;
    }

    int16_t parse_sunssf(uint16_t offset) const {
      if (!canRead(offset, 1)) {
        return 0x8000;
      }
      return static_cast<int16_t>(read_uint16(offset));
    }

    uint32_t parse_ipaddr(uint16_t offset) const {
      if (!canRead(offset, 2)) {
        return 0x00000000;
      }
      return read_uint32(offset);
    }

    /*
    uint128_t parse_ipv6addr(uint16_t offset) const {
      if (!canRead(offset, 8)) {
        return 0x00000000000000000000000000000000;
      }
      return read_uint128(offset);
    }
    */

    uint64_t parse_eui48(uint16_t offset) const {
      if (!canRead(offset, 3)) {
        return 0x000000000000;
      }
      return
        static_cast<uint64_t>(buffer_[offset    ]) << 32 |
        static_cast<uint64_t>(buffer_[offset + 1]) << 16 |
        static_cast<uint64_t>(buffer_[offset + 2]);
    }

    float parse_int16_sunssf(uint16_t offset, uint16_t scaleOffset) const {
      int16_t mantissa = parse_int16(offset);
      int16_t exponent = parse_int16(scaleOffset);
      if (mantissa == NotImplemented::INT16 || exponent == NotImplemented::SUNSSF) {
        return NotImplemented::FLOAT32;
      } 
      return static_cast<float>(mantissa) * pow10f(static_cast<float>(exponent));
    }

    float parse_uint16_sunssf(uint16_t offset, uint16_t scaleOffset) const {
      uint16_t mantissa = parse_uint16(offset);
      int16_t exponent = parse_int16(scaleOffset);
      if (mantissa == NotImplemented::UINT16 || exponent == NotImplemented::SUNSSF) {
        return NotImplemented::FLOAT32;
      } 
      return static_cast<float>(mantissa) * pow10f(static_cast<float>(exponent));
    }

    double parse_uint32_sunssf(uint16_t offset, uint16_t scaleOffset) const {
      uint32_t mantissa = parse_uint32(offset);
      int16_t exponent = parse_int16(scaleOffset);
      if (mantissa == NotImplemented::UINT32 || exponent == NotImplemented::SUNSSF) {
        return NotImplemented::FLOAT64;
      } 
      return static_cast<double>(mantissa) * pow10(static_cast<double>(exponent));
    }

    double parse_uint64_sunssf(uint16_t offset, uint16_t scaleOffset) const {
      uint64_t mantissa = parse_uint64(offset);
      int16_t exponent = parse_int16(scaleOffset);
      if (mantissa == NotImplemented::UINT64 || exponent == NotImplemented::SUNSSF) {
        return NotImplemented::FLOAT64;
      } 
      return static_cast<double>(mantissa) * pow10(static_cast<double>(exponent));
    }

    double parse_acc32_sunssf(uint16_t offset, uint16_t scaleOffset) const {
      uint32_t mantissa = parse_acc32(offset);
      int16_t exponent = parse_int16(scaleOffset);
      if (mantissa == NotImplemented::ACC32 || exponent == NotImplemented::SUNSSF) {
        return NotImplemented::FLOAT64;
      } 
      return static_cast<double>(mantissa) * pow10(static_cast<double>(exponent));
    }

  private:
    uint16 const *buffer_ = nullptr;
    uint16 bufSize_ = 0;

    SunSpecModel(SunSpecModel const &) = delete;
    SunSpecModel &operator=(SunSpecModel const &) = delete;

    /**
     * Initializes the model wrapping the given buffer. It takes ownership of
     * the buffer, so it will `delete[]` it when done.
     */
    void setBuffer(uint16 *buffer, uint16 bufSize) {
      deleteBuffer();

      if (bufSize != LENGTH) {
        ARDUINO_SUNSPEC_DEBUG_LOG("Model ");
        ARDUINO_SUNSPEC_DEBUG_LOG(ID);
        ARDUINO_SUNSPEC_DEBUG_LOG(" should have length ");
        ARDUINO_SUNSPEC_DEBUG_LOG(LENGTH);
        ARDUINO_SUNSPEC_DEBUG_LOG(" but has length ");
        ARDUINO_SUNSPEC_DEBUG_LOG(bufSize);
        if (bufSize < LENGTH) {
          ARDUINO_SUNSPEC_DEBUG_LOGLN("; missing points will be defaulted");
        } else if (bufSize > LENGTH) {
          ARDUINO_SUNSPEC_DEBUG_LOGLN("; extra registers will be ignored");
        }
      }

      buffer_ = buffer;
      bufSize_ = bufSize;
    }

    /**
     * Deletes the buffer, if any.
     */
    void deleteBuffer() {
      delete[] buffer_; // Deleting a nullptr is okay.
      buffer_ = nullptr;
      bufSize_ = 0;
    }

    /**
     * Whether the buffer holds enough registers to read this many from the
     * given offset. Deals with overflow.
     */
    bool canRead(uint16_t offset, uint16_t count) const {
      return offset + count <= bufSize_ && offset + count >= offset;
    }

    uint16_t read_uint16(uint16_t offset) const {
      return buffer_[offset];
    }

    uint32_t read_uint32(uint16_t offset) const {
      return
        static_cast<uint32_t>(buffer_[offset]    ) << 16 |
        static_cast<uint32_t>(buffer_[offset + 1]);
    }

    uint64_t read_uint64(uint16_t offset) const {
      return
        static_cast<uint64_t>(buffer_[offset    ]) << 48 |
        static_cast<uint64_t>(buffer_[offset + 1]) << 32 |
        static_cast<uint64_t>(buffer_[offset + 2]) << 16 |
        static_cast<uint64_t>(buffer_[offset + 3]);
    }

    friend class SunSpec;
};
